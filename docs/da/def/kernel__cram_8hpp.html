<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.10"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>ORIGEN API: Solver/cram/src/kernel_cram.hpp File Reference</title>
        <!--<link href="../../tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="../../dynsections.js"></script>
        <link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
        <link href="../../doxygen.css" rel="stylesheet" type="text/css" />
        <link href="../../customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="../../doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">ORIGEN API v0.5.2</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Overview</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../modules.html"><span>Components</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../d1/d5b/md__c_h_a_n_g_e_l_o_g.html"><span>Changelog</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../files.html"><span>File&#160;List</span></a></li>
      <li><a href="../../globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dir_bbfb5cf133b5ee2ba5207ad49be3b96c.html">Solver</a></li><li class="navelem"><a class="el" href="../../dir_8f3cde3fac723e4552b5504cffd18f9b.html">cram</a></li><li class="navelem"><a class="el" href="../../dir_6d6fe34b92091976de4942a550a86094.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">kernel_cram.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header for <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html" title="CRAM depletion solver. ">kernel_cram.cpp</a>, <a class="el" href="../../d8/da3/kernel__cram__coefficients_8cpp.html" title="Coefficients for CRAM depletion solver. ">kernel_cram_coefficients.cpp</a> and <a class="el" href="../../dd/d7e/kernel__cram__from__fortran_8cpp.html" title="Interface function for calling kernel_cram() from Fortran. ">kernel_cram_from_fortran.cpp</a>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;ScaleUtils/SuperLU/SRC/slu_dcomplex.h&quot;</code><br />
<code>#include &quot;Standard/Interface/Reporter.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a45c654949dcb526cf76cdd65498a4ceb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/def/kernel__cram_8hpp.html#a45c654949dcb526cf76cdd65498a4ceb">kernel_cram</a> (double *n, double *n0, double **source_term, int source_order, double delta_t, int itot, int non, int *non0, int *kd, double *diag, double *a, int *loc, int zero_flux_step, int is_adjoint, int cram_order, int internal_steps, int remove_negatives, double cutoff, int *ZAI)</td></tr>
<tr class="separator:a45c654949dcb526cf76cdd65498a4ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17888fff360262af994463a57b69e1a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/def/kernel__cram_8hpp.html#a17888fff360262af994463a57b69e1a3">OrigenToCRSMatrix</a> (int *a_n, double **p_a_val, int **p_a_ci, int **p_a_rp, int **p_a_diag_idx, int *a_nnz, int **p_newIdx, int **p_oldIdx, double **src_dummy_n0, int itot, int non, int *non0, int *kd, double *diag, double *offdiag, int *loc, double **source_term, int source_order, int zero_flux_step, int is_adjoint, int sort_nuclides, int *ZAI)</td></tr>
<tr class="separator:a17888fff360262af994463a57b69e1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa519e485bd96a0c81aa4d4fd56b96926"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/def/kernel__cram_8hpp.html#aa519e485bd96a0c81aa4d4fd56b96926">kernel_cram_from_fortran</a> (double *n, double *n0, double *source_term, int source_order, double delta_t, int itot, int non, int *non0, int *kd, double *diag, double *a, int *loc, int zero_flux_step, int is_adjoint, int cram_order, int internal_steps, int remove_negatives, double cutoff, int *ZAI)</td></tr>
<tr class="separator:aa519e485bd96a0c81aa4d4fd56b96926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79aa009834d9b4a50ef6fc96f89e5d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/def/kernel__cram_8hpp.html#af79aa009834d9b4a50ef6fc96f89e5d7">kernel_cram_coefficients</a> (doublecomplex *alpha0, doublecomplex *alpha, doublecomplex *theta, int cram_order)</td></tr>
<tr class="separator:af79aa009834d9b4a50ef6fc96f89e5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header for <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html" title="CRAM depletion solver. ">kernel_cram.cpp</a>, <a class="el" href="../../d8/da3/kernel__cram__coefficients_8cpp.html" title="Coefficients for CRAM depletion solver. ">kernel_cram_coefficients.cpp</a> and <a class="el" href="../../dd/d7e/kernel__cram__from__fortran_8cpp.html" title="Interface function for calling kernel_cram() from Fortran. ">kernel_cram_from_fortran.cpp</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Aarno Isotalo </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a45c654949dcb526cf76cdd65498a4ceb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kernel_cram </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>n_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>n0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>source_term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>non</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>non0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>offdiag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zero_flux_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_adjoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cram_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>internal_steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>remove_negatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ZAI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CRAM depletion solver with source term and adjoint capabilities.</p>
<p>Based on the publication: Pusa, M. and Leppänen, J. "Computing the matrix exponential in burnup
  calculations." Nucl. Sci. Eng., 164 (2010) 140-150.</p>
<p>The required linear system solutions are done with the SuperLU library: Xiaoye S. Li. "An Overview of {SuperLU}: Algorithms, Implementation, and
  User Interface." ACM Trans.Math. Softw., 31;3 (2005) 302-325.</p>
<p><b>Fortran</b> should call <a class="el" href="../../da/def/kernel__cram_8hpp.html#aa519e485bd96a0c81aa4d4fd56b96926">kernel_cram_from_fortran()</a> instead.</p>
<p><b>Source term</b> can have polynomial time dependency. Due to numerical issues source order is limited to cram_order/2-2. Non constant source term will cause some deterioration in accuracy, but below this limit it should be negligible.</p>
<p><b>Adjoint calculation</b> is also possible by passing is_adjoint=1. In adjoint mode n0, source_term and delta_t&gt;0 must be those for the adjoint problem while everything else must have values defining the forward system.</p>
<p><b>Internal substeps:</b> Dividin steps to pieces greatly improved accuracy. This is particularly significant for decay problems where accuracy without might not be good enough for all purposes. The solver can do this division internally, which is more efficient than calling the solver multiple times as the LU decompositions only need to be formed once. internal_steps=1 means means that there is no substepping. Setting internal_steps=2 increases running time by roughly 25%. Each substep above 2 increases it by another 10-15% of the running time without substepping. See *** for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">n_out[itot]</td><td>Final concentrations. Must be Pre-allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n0[itot]</td><td>Initial concentrations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source_term[itot][source_order+1]</td><td>Polynomial coefficients s_i,j for the source term </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source_order</td><td>Order of the source term polynomial </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta_t</td><td>Length of the time step in seconds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itot</td><td>The number of nuclides in the system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">non</td><td>Number of reactions (inc. decay) in the system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">non0[itot]</td><td>Number of parents for each nuclide </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kd[itot]</td><td>Number of decay parents for each nuclide </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diag[itot]</td><td>Diagonal elements of A, i.e., (-lambda_eff) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offdiag[non]</td><td>Reaction specific decay constant of each reaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">loc[non]</td><td>Index of the parent in each reaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zero_flux_step</td><td>Logical integer, is the flux zero? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_adjoint</td><td>Logical integer, is this adjoint calculation? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cram_order</td><td>Order of the CRAM approximation (just use 16). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal_steps</td><td>Number of internal substeps to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remove_negatives</td><td>How to treat negative vaues in results: 0: Do nothing. 1: Remove all negative values. 2: Remove all negative values in forward mode. Remove all negative values in adjoint mode if source term is constant and both source and initial concentrations are non-negative. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cutoff</td><td>Concentrations whose ABSOLUTE value is below cutoff times sum(abs(n_out)) are set to zero. This is applied after remove_negatives. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ZAI[itot]</td><td>ZAI identifiers of the nuclides.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The indexing in loc must be in c style, i.e., starts from 0. Be avare of this when calling from Fortran.</dd>
<dd>
offdiag (which is called "a" in most of <a class="el" href="../../d5/dc1/namespace_origen.html">Origen</a> source code) and loc must be sorted in the special <a class="el" href="../../d5/dc1/namespace_origen.html">Origen</a> way:<ul>
<li>decay parents of first nuclide,</li>
<li>activation parents of first nuclide,</li>
<li>decay parents of second nuclide,</li>
<li>activation parents of the second,</li>
<li>and so on.</li>
</ul>
</dd>
<dd>
The culling feature from earlier versions was removed. Use internal substeps instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>zero on successfull exit or nonzero on failed exit. On failed exit the results (i.e., n) are unspecified. </dd></dl>

<p>References <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a246b07e575efe303e340da78c4e3e15c">CopyLU()</a>, <a class="el" href="../../d5/dc1/namespace_origen.html#acac5275310c6e0fef2672b821eb08e38">Origen::info()</a>, <a class="el" href="../../da/def/kernel__cram_8hpp.html#af79aa009834d9b4a50ef6fc96f89e5d7">kernel_cram_coefficients()</a>, <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#aff5a005e75ba1c528c5f8597d45cb1cb">makeExpmInput()</a>, <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a8109e19dd4e4009213d14ae3d68214f5">makeMatlabInput()</a>, <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a47f2e62c0dbebc787052c165afcada0e">NAME</a>, <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a766915c86655672579fe5205b19bc692">OrigenToCRSMatrix()</a>, <a class="el" href="../../d8/dc8/_fake_factory_8cpp.html#a6deea1c2ba17f0529b284f5013940b9f">r</a>, and <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#af2e1575f3f81b75079edded741a589e3">SORT_NUCLIDES</a>.</p>

<p>Referenced by <a class="el" href="../../dd/d7e/kernel__cram__from__fortran_8cpp.html#aa6eba8d39329bf76318552b1837726b9">kernel_cram_from_fortran()</a>, and <a class="el" href="../../d4/d53/class_origen_1_1_solver__cram.html#a415be826c056e1634b7b7265380c27b3">Solver_cram::solve_impl()</a>.</p>

</div>
</div>
<a class="anchor" id="a17888fff360262af994463a57b69e1a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OrigenToCRSMatrix </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>p_a_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>p_a_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>p_a_ci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>p_a_rp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>p_a_diag_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>p_a_nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>p_newIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>p_oldIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>p_src_dummy_n0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>non</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>non0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>offdiag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>source_term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zero_flux_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_adjoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sort_nuclides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ZAI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert ORIGEN form input to regular compressed row storage (CRS) matrix representing the equivalent homogeneous equations.</p>
<p>This has two main functions:</p><ul>
<li>Build the actual coefficient matrix</li>
<li>Homogenize the equations (i.e., dn/dt = An +s ==&gt; dn'/dt = A'n')</li>
</ul>
<p>which are done simultaneously. In addition this:</p><ul>
<li>Allocates all diagonal elements (even zeros)</li>
<li>Sorts nuclides by ZAI</li>
<li>Sorts each row</li>
</ul>
<p>For details about the homogenization see: </p><hr/>
<dl class="section note"><dt>Note</dt><dd>The first nine arguments are used for output. They are pointers to the variables p_&lt;name in kernel_cram()&gt; The other arguments are same as for <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a280cd76fe988677c00f96930b194e4a4">kernel_cram()</a>. The output, except for p_a_n and p_a_nnz which are scalars, will be allocated by this function. </dd></dl>

<p>References <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a9ce670e6925467c50c380d67ffe4dbd7">sortCRSnuclides()</a>.</p>

<p>Referenced by <a class="el" href="../../da/def/kernel__cram_8hpp.html#a45c654949dcb526cf76cdd65498a4ceb">kernel_cram()</a>.</p>

</div>
</div>
<a class="anchor" id="aa519e485bd96a0c81aa4d4fd56b96926"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kernel_cram_from_fortran </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>n0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>source_term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>non</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>non0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>offdiag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zero_flux_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_adjoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cram_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>internal_steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>remove_negatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ZAI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface function for calling <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a280cd76fe988677c00f96930b194e4a4">kernel_cram()</a> from Fortran. Converts the source_term to the form expected by <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a280cd76fe988677c00f96930b194e4a4">kernel_cram()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>All arguments are the same as for <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a280cd76fe988677c00f96930b194e4a4">kernel_cram()</a>, except that source_term is a 1D array whose elements must be ordered so that the coefficients for given nuclide are consequtive in memory. This only converts source_term, loc indexing must be converted by the caller.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS or EXIT_FAILURE. On failed exit the results (i.e., n) are unspecified. </dd></dl>

<p>References <a class="el" href="../../d6/dfc/kernel__cram_8cpp.html#a280cd76fe988677c00f96930b194e4a4">kernel_cram()</a>.</p>

</div>
</div>
<a class="anchor" id="af79aa009834d9b4a50ef6fc96f89e5d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kernel_cram_coefficients </td>
          <td>(</td>
          <td class="paramtype">doublecomplex *&#160;</td>
          <td class="paramname"><em>alpha0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">doublecomplex *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">doublecomplex *&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cram_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set CRAM coefficients for partial fraction decomposition form.</p>
<p>Sets the poles and residues of chebyshev rational approximation on the negative real axis. Available orders are 4, 6, 8, 10, 12, 14, and 16.</p>
<p>Order 14 and 16 coefficients are from: Maria Pusa, "Correction to partial fraction decomposition coefficients
   for Chebyshev rational approximation on the negative real axis." arXiv:1206.2880v1 [math.NA] (2013). Others have been provided by Maria Pusa directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">alpha0,alpha,theta</td><td>The coefficients. alpha and theta must be preallocated to hold at least order/2 values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cram_order</td><td>The desired order of the CRAM approximation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS or EXIT_FAILURE. On failed exit the results are unspecified. </dd></dl>

<p>References <a class="el" href="../../d8/da3/kernel__cram__coefficients_8cpp.html#a47f2e62c0dbebc787052c165afcada0e">NAME</a>.</p>

<p>Referenced by <a class="el" href="../../da/def/kernel__cram_8hpp.html#a45c654949dcb526cf76cdd65498a4ceb">kernel_cram()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
